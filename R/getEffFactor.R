# pre- and post-multiply NTginvATN by block projection matrices produces the
# effFactors for each stratum




#' Compute the Efficiency Factors of Treatment effects
#' 
#' Compute the Efficiency Factors for every treatment effect within a single
#' stratum.
#' 
#' The main purpose of this function is to compute the canoncial or average
#' efficiency factors for each treatment effects in each stratum of ANOVA
#' table.
#' 
#' The canoncial efficiency factors are generated when the user input the
#' treatment contrasts, otherwise the average efficiency factors, which is the
#' harmomic mean of the canoncial efficiency factors, are gnerated.
#' 
#' @param z a matrix containing the orthogonal projector of a stratum generated
#' by \code{\link{makeOrthProjectors}}.
#' @param T a list of contrast matrices generated by
#' \code{\link{makeContrMat}}.
#' @param N a matrix containing the design matrix generated by
#' \code{\link{makeOverDesMat}}.
#' @param Rep a numeric vector containing the treatment replication number
#' generated by \code{\link{getTrtRep}}
#' @return A list of numeric vectors containing the efficiency factors of every
#' treatment effect.
#' @author Kevin Chang
#' @examples
#' 
#' design1 <- local({ 
#'   Ani = as.factor(LETTERS[c(1,2,3,4,
#'                             5,6,7,8)])
#'   Trt = as.factor(letters[c(1,1,1,1,
#'                             2,2,2,2)])
#'   data.frame(Ani, Trt)
#' })
#' 
#' blk.str = "Ani"
#'     
#' rT = terms(as.formula(paste("~", blk.str, sep = "")), keep.order = TRUE) 
#' blkTerm = attr(rT,"term.labels")
#'      
#' Z = makeBlkDesMat(design1, blkTerm)
#' 
#' trt.str = "Trt"              
#' fT <- terms(as.formula(paste("~", trt.str, sep = "")), keep.order = TRUE)  #fixed terms
#' 
#' trtTerm <- attr(fT, "term.labels")
#' effectsMatrix <- attr(fT, "factor")        
#' 
#' T <- makeContrMat(design1, trtTerm, effectsMatrix, contr.vec = NA)
#' 
#' N =  makeOverDesMat(design1, trtTerm)
#' 
#' Rep = getTrtRep(design1, trtTerm)   
#'  
#' effFactors = lapply(makeOrthProjectors(Z), function(z) getEffFactor(z, T, N, Rep))
#' 
#' 
#' @export getEffFactor
getEffFactor <- function(z, T, N, Rep) {
    
    if (!is.matrix(z)) 
        return(z)
    
    nEffect <- length(T)
    PNTginvATNP <- effFactors <- vector("list", nEffect)
    
    names(PNTginvATNP) <- names(effFactors) <- names(T)
    
    PNTginvATNP[[1]] <- PNTginvATNP(z, N, T[[1]], invInfMat(C = z, N = N, T = T[[1]]))
    #PNTginvATNP[[1]] <- z %*% N %*% T[[1]] %*% invInfMat(C = z, N = N, T = T[[1]]) %*% 
    #    T[[1]] %*% t(N) %*% t(z)
    
    if (!all(PNTginvATNP[[1]] < 1e-06)) {
        effFactors[[1]] <- vector("list", nEffect)
        names(effFactors[[1]]) <- names(T)
        for (i in 1:nEffect) {
            r.adjust <- ginv(sqrt(diag(Rep[, i])))
            # eigenvalues of the information matrix
            va <- Re(eigenPNTginvATNP(r.adjust, N,  T[[i]],  PNTginvATNP[[1]]))
            #va <- Re(eigen(r.adjust %*% T[[i]] %*% t(N) %*% PNTginvATNP[[1]] %*% N %*% 
            #    T[[i]] %*% r.adjust)$va)
            
          
            
            # harmonic means of the canonical efficiency factors to give the average efficiency
            # factor
            effFactors[[1]][[i]] <- 1/mean(1/va[which(va > 1e-07)])
        }
    }
    
    newZ <- (z %*% t(z)) - PNTginvATNP[[1]]
    
    if (nEffect != 1) {
        for (i in 2:nEffect) {
            
          PNTginvATNP[[i]] <- PNTginvATNP(newZ, N, T[[i]], invInfMat(C = newZ, N = N, T = T[[i]]))
          
          #PNTginvATNP[[i]] <- newZ %*% N %*% T[[i]] %*% invInfMat(C = newZ, N = N, 
           #     T = T[[i]]) %*% T[[i]] %*% t(N) %*% t(newZ)
            
            # PNTginvATNP[[i]] = newZ %*% N %*% t(T[[i]]) %*% ginv(t(T[[i]]) %*% t(N) %*% z %*%
            # N %*% T[[i]]) %*% T[[i]] %*% t(N) %*% t(newZ)
			
            if (all(PNTginvATNP[[i]] < 1e-06)) 
                next
            
            effFactors[[i]] <- vector("list", nEffect)
            names(effFactors[[i]]) <- names(T)
            for (j in 1:nEffect) {
                r.adjust <- ginv(sqrt(diag(Rep[, j])))
                va <- Re(eigenPNTginvATNP(r.adjust, N, T[[j]],  PNTginvATNP[[i]]))
                
                #va <- Re(eigen(r.adjust %*% T[[j]] %*% t(N) %*% PNTginvATNP[[i]] %*% 
                #  N %*% T[[j]] %*% r.adjust)$va)
                # va = Re(eigen(T[[j]] %*% t(N) %*% PNTginvATNP[[i]] %*% N %*% T[[j]])$va)
                
                # effFactors[[i]][[j]] = 1/mean(Rep[names(T[j])]/va[which(va>1e-6)])
                effFactors[[i]][[j]] <- 1/mean(1/va[which(va > 1e-07)])
                
            }
            newZ <- (newZ %*% t(newZ)) - PNTginvATNP[[i]]
            
        }
    }
    
    return(effFactors)
} 
